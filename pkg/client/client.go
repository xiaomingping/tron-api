package client

import (
	"errors"
	"fmt"
	"github.com/gogf/gf/frame/g"
	"github.com/gogf/gf/net/ghttp"
	"github.com/gogf/gf/text/gstr"
	"github.com/gogf/gf/util/gconv"
	"github.com/shopspring/decimal"
	"github.com/xiaomingping/tron-api/pkg/address"
	"github.com/xiaomingping/tron-api/pkg/base58"
	"github.com/xiaomingping/tron-api/pkg/hexutil"
	"math/big"
	"sync"
)

const (
	ApiUrl       = "https://api.trongrid.io"        // 主网
	ApiUrlShasta = "https://api.shasta.trongrid.io" // Shasta测试网
)

var (
	curIndex        = 0
	mutex           sync.Mutex
	ApiKeys         []string
	startNum int64 = 32091379
	// 最后校验块
	count    int64 = 20       // 每次获取块数量
	trxdecimal      int32 = 6 // trx 单位
	mapContract           = make(map[string]*ContractModel)
	mapContractType       = map[string]bool{
		"trx":   true,
		"trc10": true,
		"trc20": true,
	}
)

func SetStartNum(StartNum int64) {
	connMutex.Lock()
	startNum = StartNum
	defer connMutex.Unlock()
}
func GetStartNum() int64 {
	return startNum
}

// 初始化合约
func InitContract(contracts []ContractModel) error {
	for i, v := range contracts {
		if ok, _ := mapContractType[v.Type]; ok {
			mapContract[v.Contract] = &contracts[i]
		} else {
			return fmt.Errorf("the contract type %s is not exist pleasecheck", v.Type)
		}
	}

	return nil
}

// 判断当前属于什么合约
func ChargeContract(contract string) (string, int32) {
	if contract == "trx" || contract == "" {
		return Trx, trxdecimal
	}
	if v := mapContract[contract]; v != nil {
		if ok, _ := mapContractType[v.Type]; ok {
			return v.Type, v.Decimal
		}
	}
	return "NONE", 18
}

func ChargeContractObj(contract string) *ContractModel {
	if v, ok := mapContract[contract]; ok {
		return v
	}
	return nil
}

// 5527c743-dc35-4a00-8b97-7e75ac9c164b
// 4c492539-5e03-452b-9633-6e5b8998cc36
type Client struct {
	Url string
}

func NewClient() *Client {
	return &Client{Url: ApiUrl}
}

// 获取请求客户端
func (c *Client) getClient() *ghttp.Client {
	Client := ghttp.NewClient()
	Client.SetHeader("Content-Type", "application/json")
	Client.SetHeader("TRON-PRO-API-KEY", c.getApiKey())
	return Client
}

// 获取api key
func (c *Client) getApiKey() string {
	mutex.Lock()
	defer mutex.Unlock()
	lens := len(ApiKeys)
	if curIndex >= lens {
		curIndex = 0
	}
	inst := ApiKeys[curIndex]
	curIndex = (curIndex + 1) % lens
	return inst
}

// 获取用户信息
func (c *Client) GetAccount(address string) (*GetAccountModel, error) {
	url := fmt.Sprintf("%s/v1/accounts/%s", c.Url, address)
	body := c.getClient().GetVar(url)
	if body.IsEmpty() {
		return nil, errors.New("网络错误")
	}
	var Account RespAccount
	err := body.Struct(&Account)
	if err != nil {
		g.Log().Error(err)
		return nil, err
	}
	if Account.Success != true {
		return nil, errors.New("连接失败")
	}
	if len(Account.Data) == 0 {
		return nil, errors.New("账号未激活")
	}
	return &Account.Data[0], nil
}

// 进度转换
func BalanceAccuracy(Balance string, exp int32) string {
	b, _ := decimal.NewFromString(Balance)
	return b.Mul(decimal.New(1, exp)).String()
}

// 获取余额
func GetTRXBalance(req *GetAccountModel) map[string]string {
	BalanceModel := make(map[string]string)
	BalanceModel[Trx] = ""
	for _, ContractModel := range mapContract {
		BalanceModel[ContractModel.Name] = "0"
	}
	Balance := gconv.Int64(req.Balance)
	BalanceModel[Trx] = BalanceAccuracy(gconv.String(Balance), -trxdecimal)
	for _, Tokens := range req.Trc20 {
		for key, val := range Tokens {
			if v := ChargeContractObj(key); v != nil {
				BalanceModel[v.Name] = BalanceAccuracy(gconv.String(val), -v.Decimal)
			}
		}
	}
	return BalanceModel
}

// 获取账户历史TRC20交易记录
func (c *Client) GetTransactionsTrc20(address, contract string, ) ([]TransactionsTrc20Model, error) {
	url := fmt.Sprintf("%s/v1/accounts/%s/transactions/trc20?only_confirmed=true&only_to=true&contract_address=%s", c.Url, address, contract)
	body := c.getClient().GetVar(url)
	if body.IsEmpty() {
		return nil, errors.New("网络错误")
	}
	var TransactionsTrc20 RespTransactionsTrc20
	err := body.Struct(&TransactionsTrc20)
	if err != nil {
		g.Log().Error(err)
		return nil, err
	}
	if TransactionsTrc20.Success != true {
		return nil, errors.New("连接失败")
	}
	return TransactionsTrc20.Data, nil
}

// 获取区块详情
func (c *Client) GetBlockById(exchangeId string) (*ContractBlockInfo, error) {
	url := fmt.Sprintf("%s/event/transaction/%s", c.Url, exchangeId)
	body := c.getClient().GetVar(url)
	if body.IsEmpty() {
		return nil, errors.New("网络错误")
	}
	var AutoGenerated []AutoGenerated
	err := body.Structs(&AutoGenerated)
	if err != nil {
		g.Log().Error(err)
		return nil, err
	}
	if len(AutoGenerated) == 0 {
		return nil, errors.New("没有此交易")
	}
	return &ContractBlockInfo{
		TransactionID:   AutoGenerated[0].TransactionID,
		BlockNumber:     AutoGenerated[0].BlockNumber,
		EventName:       AutoGenerated[0].EventName,
		BlockTimestamp:  AutoGenerated[0].BlockTimestamp,
		ContractAddress: AutoGenerated[0].ContractAddress,
		From:            address.HexTOString(AutoGenerated[0].Result.From),
		To:              address.HexTOString(AutoGenerated[0].Result.To),
		Value:           AutoGenerated[0].Result.Value,
		EventIndex:      AutoGenerated[0].EventIndex,
	}, nil
}

// 获取最新块数据
func (c *Client) GetBlockByLimitNext(Transfer func(*TransferData)) {
	URL := fmt.Sprintf("%s/wallet/getblockbylimitnext", c.Url)
	body := c.getClient().PostVar(URL, g.Map{"startNum": startNum, "endNum": startNum + count})
	if body.IsEmpty() {
		return
	}
	var NewBlock NewBlock
	err := body.Structs(&NewBlock)
	if err != nil {
		g.Log().Error(err)
		return
	}
	StartNum := startNum + int64(len(NewBlock.Block))
	SetStartNum(StartNum)
	for _, v := range NewBlock.Block {
		c.ProcessBlock(v, Transfer)
	}
}

func (c *Client) ProcessBlock(block Block, Transfer func(*TransferData)) {
	for _, v := range block.Transactions {
		txId := v.TxID
		for _, val := range v.RawData.Contract {
			switch val.Type {
			case "TransferContract": // trc
				// trx 转账
				unObj := &Trc{}
				err := gconv.Struct(val.Parameter.Value, unObj)
				if err != nil {
					fmt.Printf("parse Contract %v err: %v\n", val, err)
					continue
				}
				HexForm, _ := hexutil.Hex2Bytes(unObj.OwnerAddress)
				form := base58.EncodeCheck(HexForm)
				HexTo, _ := hexutil.Hex2Bytes(unObj.ToAddress)
				to := base58.EncodeCheck(HexTo)
				Transfer(&TransferData{FormAddress: form, ToAddress: to, Amount: unObj.Amount, Contract: "trx", TxId: txId})
			case "TransferAssetContract": // trc10
				continue
			case "TriggerSmartContract":
				// trc20 转账
				unObj := &Value{}
				err := gconv.Struct(val.Parameter.Value, unObj)
				if err != nil {
					fmt.Printf("parse Contract %v err: %v\n", val, err)
					continue
				}
				HexContract, _ := hexutil.Hex2Bytes(unObj.ContractAddress)
				contract := base58.EncodeCheck(HexContract)
				HexForm, _ := hexutil.Hex2Bytes(unObj.OwnerAddress)
				form := base58.EncodeCheck(HexForm)
				// unObj.Data  https://goethereumbook.org/en/transfer-tokens/ 参考eth 操作
				to, amount, flag := c.processTransferData(unObj.Data)
				if flag { // 只有调用了 transfer(address,uint256) 才是转账
					Transfer(&TransferData{FormAddress: form, ToAddress: to, Amount: amount, Contract: contract, TxId: txId})
				}
			}
		}
	}
}

// 处理合约参数
func (c *Client) processTransferData(trc20 string) (to string, amount int64, flag bool) {
	if len(trc20) >= 68 {
		if gstr.SubStr(trc20, 0, 8) != "a9059cbb" {
			return
		}
		addressHex := string(TrimLeftZeroes(gconv.Bytes(gstr.SubStr(trc20, 8, 64))))
		if len(addressHex) != 42 {
			addressHex = "41" + addressHex
		}
		to = address.HexTOString(addressHex)
		amountHex, _ := hexutil.Hex2Bytes(string(TrimLeftZeroes(gconv.Bytes(gstr.SubStr(trc20, 72, 64)))))
		amount = new(big.Int).SetBytes(amountHex).Int64()
		flag = true
	}
	return
}